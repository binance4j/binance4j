"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[4261],{1345:(e,n,t)=>{t(814),t(5162),t(5488),t(7294)},4032:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>k,frontMatter:()=>c,metadata:()=>l,toc:()=>d});var o=t(7462),a=(t(7294),t(3905)),i=t(2106),s=t(6251);t(1345);const c={title:"Connectors"},r=void 0,l={unversionedId:"connectors",id:"version-2.x/connectors",title:"Connectors",description:"Description",source:"@site/versioned_docs/version-2.x/15-connectors.mdx",sourceDirName:".",slug:"/connectors",permalink:"/binance4j/binance4j-documentation/docs/connectors",draft:!1,editUrl:"https://github.com/binance4j/binance4j/versioned_docs/version-2.x/15-connectors.mdx",tags:[],version:"2.x",sidebarPosition:15,frontMatter:{title:"Connectors"},sidebar:"tutorialSidebar",previous:{title:"Core",permalink:"/binance4j/binance4j-documentation/docs/Core"},next:{title:"BLVT endpoints",permalink:"/binance4j/binance4j-documentation/docs/blvt"}},p={},d=[{value:"Description",id:"description",level:2},{value:"Installation",id:"installation",level:2},{value:"Connectors class",id:"connectors-class",level:2},{value:"Calling a client",id:"calling-a-client",level:2},{value:"Updating the API keys",id:"updating-the-api-keys",level:2}],u={toc:d};function k(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)(s.ZP,{artifact:"connectors",mdxType:"RepoBadges"}),(0,a.kt)("h2",{id:"description"},"Description"),(0,a.kt)("p",null,"All REST and Websocket connectors in one place."),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)(i.ZP,{repo:"connectors",mdxType:"ArtifactInstall"}),(0,a.kt)("h2",{id:"connectors-class"},"Connectors class"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Conectors")," class is the entry point of every client. It receives the API keys at instantiation."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"Connectors connectors = new Connectors(key, secret);\n")),(0,a.kt)("h2",{id:"calling-a-client"},"Calling a client"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Conectors")," instance will lazy load the clients, meaning it won't instantiate every client at once but just when needed.\nThe client is then cached and the same instance is returned every time."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"// First call, the client is instantiated.\nconnectors.market().getServerTime().sync();\n// Second call, the same instance is returned.\nconnectors.market().getBookTicker().sync();\n")),(0,a.kt)("h2",{id:"updating-the-api-keys"},"Updating the API keys"),(0,a.kt)("p",null,"Every time you call a client, it will check if its keys are equal to the container keys and update them if not. This feature is really useful if you want to implement a proxy server for multiple users for example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"//Updating keys in the container\nconnectors.updateKeys(key,secret);\n//keys have changed, they are updated in the client when it is called\nconnectors.spot();\n//keys haven't changed, nothing happens\nconnectors.spot();\n")))}k.isMDXComponent=!0},2106:(e,n,t)=>{t.d(n,{ZP:()=>r});var o=t(7462),a=(t(7294),t(3905)),i=t(112),s=t(6867);const c={toc:[]};function r(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)(i.Z,{repo:t.repo,version:s.i,mdxType:"InstallationInstructions"}))}r.isMDXComponent=!0},6251:(e,n,t)=>{t.d(n,{ZP:()=>r});var o=t(7462),a=(t(7294),t(3905)),i=t(8267),s=t(6867);const c={toc:[]};function r(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)(i.Z,{artifact:t.artifact,version:s.i,mdxType:"RepoBadges"}))}r.isMDXComponent=!0},6867:e=>{e.exports={i:"2.0.7"}}}]);