"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[544],{1345:(e,t,a)=>{a.d(t,{ZP:()=>d});var n=a(814),i=a(5162),r=a(5488),s=a(7294);function l(e){return s.createElement(n.Z,{language:"java"},"try{\n    "+e.payload+" res = client."+e.method+".sync();\n}catch(ApiException e){ \n//...\n}")}function o(e){return s.createElement(n.Z,{language:"java"},"client."+e.method+".async(response->{\n//...\n});")}function c(e){const t=e.payload?e.payload+" response":"";return s.createElement(n.Z,{language:"java"},"client."+e.method+".async(new ApiCallback<"+(e.payload?e.payload:"Void")+">() {\n    @Override\n    public void onResponse("+t+") {\n        //...\n    }\n\n    @Override\n    public void onFailure(ApiException exception) {\n        //...\n    }\n});\n")}function d(e){return s.createElement(s.Fragment,null,s.createElement(r.Z,null,s.createElement(i.Z,{label:"Sync",value:"sync",default:!0},s.createElement(l,e)),s.createElement(i.Z,{label:"Async (lambda)",value:"async-lambda"},s.createElement(o,e)),s.createElement(i.Z,{label:"Async (ApiCallback)",value:"async-api-callback"},s.createElement(c,e))))}},9338:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>g,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>d,toc:()=>u});var n=a(7462),i=(a(7294),a(3905)),r=(a(5162),a(5488),a(814),a(112)),s=a(9098),l=(a(1345),a(8306));const o={title:"Manipulate trading strategies"},c=void 0,d={unversionedId:"strategy",id:"strategy",title:"Manipulate trading strategies",description:";",source:"@site/docs/210-strategy.mdx",sourceDirName:".",slug:"/strategy",permalink:"/binance4j/binance4j-documentation/docs/next/strategy",draft:!1,editUrl:"https://github.com/binance4j/docs/210-strategy.mdx",tags:[],version:"current",sidebarPosition:210,frontMatter:{title:"Manipulate trading strategies"},sidebar:"tutorialSidebar",previous:{title:"Websocket streams",permalink:"/binance4j/binance4j-documentation/docs/next/websocket"}},g={},u=[{value:"Description",id:"description",level:2},{value:"Installation",id:"installation",level:2},{value:"What is a trading strategy?",id:"what-is-a-trading-strategy",level:2},{value:"Creating a trading strategy",id:"creating-a-trading-strategy",level:2},{value:"Backtesting a strategy",id:"backtesting-a-strategy",level:2},{value:"With existing data",id:"with-existing-data",level:3},{value:"With inner vision client",id:"with-inner-vision-client",level:3},{value:"Get the strategy position other a BarSeries",id:"get-the-strategy-position-other-a-barseries",level:2},{value:"Live trading",id:"live-trading",level:2}],p={toc:u};function h(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(s.Z,{artifact:"strategy",version:l.i,mdxType:"RepoBadges"}),";",(0,i.kt)("h2",{id:"description"},"Description"),(0,i.kt)("p",null,"Binance4j-strategy adds technical analysis for the binance4j ecosystem thanks to ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ta4j/ta4j"},"ta4j")," indicators and rules."),(0,i.kt)("h2",{id:"installation"},"Installation"),(0,i.kt)(r.Z,{repo:"strategy",version:l.i,mdxType:"InstallationInstructions"}),(0,i.kt)("h2",{id:"what-is-a-trading-strategy"},"What is a trading strategy?"),(0,i.kt)("p",null,"A trading strategy is a class containing two methods receiveing a BarSeries as an input and returning a trading Rule as an output, the first will send a BUY signal and the other a SELL signal."),(0,i.kt)("p",null,"Every trading strategy must implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"TradingStrategy")," interface. This is the signature of the interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public interface TradingStrategy {\n    // The BUY signal\n    Rule entry(BarSeries series);\n\n    // The SELL signal\n    Rule exit(BarSeries series);\n}\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Binance4j-strategy uses ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ta4j/ta4j"},"ta4j")," for technical analysis, don't hesitate to read their documentation to understand what are indicators and rules.")),(0,i.kt)("h2",{id:"creating-a-trading-strategy"},"Creating a trading strategy"),(0,i.kt)("p",null,"Here is a trading strategy using the two period RSI indicator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class TwoPeriodRSIStrategy implements TradingStrategy {\n    @Override\n    public Rule entry(BarSeries series) {\n        ClosePriceIndicator closePrice = new ClosePriceIndicator(series);\n        SMAIndicator shortSma = new SMAIndicator(closePrice, 5);\n        SMAIndicator longSma = new SMAIndicator(closePrice, 200);\n        // We use a 2-period RSI indicator to identify buying\n        // or selling opportunities within the bigger trend.\n        RSIIndicator rsi = new RSIIndicator(closePrice, 2); // Entry rule\n        // The long-term trend is up when a security is above its 200-period SMA.\n        return new OverIndicatorRule(shortSma, longSma) // Trend\n                .and(new CrossedDownIndicatorRule(rsi, 5)) // Signal 1\n                .and(new OverIndicatorRule(shortSma, closePrice)); // Signal 2\n    }\n\n    @Override\n    public Rule exit(BarSeries series) {\n        ClosePriceIndicator closePrice = new ClosePriceIndicator(series);\n        SMAIndicator shortSma = new SMAIndicator(closePrice, 5);\n        SMAIndicator longSma = new SMAIndicator(closePrice, 200); // We use a 2-period RSI indicator to identify buying\n        // or selling opportunities within the bigger trend.\n        RSIIndicator rsi = new RSIIndicator(closePrice, 2); // Exit rule\n        // The long-term trend is down when a security is below its 200-period SMA.\n        return new UnderIndicatorRule(shortSma, longSma) // Trend\n                .and(new CrossedUpIndicatorRule(rsi, 95)) // Signal 1\n                .and(new UnderIndicatorRule(shortSma, closePrice)); // Signal 2\n    }\n}\n")),(0,i.kt)("h2",{id:"backtesting-a-strategy"},"Backtesting a strategy"),(0,i.kt)("p",null,"Binance4j can backtest a trading strategy in many ways."),(0,i.kt)("h3",{id:"with-existing-data"},"With existing data"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'// Here we get historical klines data from the public data API.\nList<Candle> bars = new VisionSpotClient().getKlines("BTCBUSD", CandlestickInterval.FIVE_MINUTES, "2022", "01").getData();\n\n// let\'s give it to the BackTestService. CandlestickInterval must match.\nBackTestResult result = BackTestService.backTest(strategy, bars, CandlestickInterval.FIVE_MINUTES);\n\n// we can also use a ta4j Barseries instance. Let\'s convert the existing candles\nBarSeries series = BarSeriesService.convert(bars,CandlestickInterval.FIVE_MINUTES);\n\nBackTestResult result = BackTestService.backTest(strategy, series);\n')),(0,i.kt)("h3",{id:"with-inner-vision-client"},"With inner vision client"),(0,i.kt)("p",null,"The service can automatically use an instance of a VisionSpotClient to collect public data from the Binance API."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'// The service will automatically use an instance of a VisionClient to get the data from the API\nBackTestResult result = BackTestService.backTest(strategy, "BTCBUSD", CandlestickInterval.FIVE_MINUTES, "2022", "01");\n')),(0,i.kt)("h2",{id:"get-the-strategy-position-other-a-barseries"},"Get the strategy position other a BarSeries"),(0,i.kt)("p",null,"The PositionService service can give us the position of our strategy over a BarSeries instance."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"//The service will tell us if the strategy sends a BUY signal over the given index on the BarSeries\nboolean shouldEnter = PositionService.shouldEnter(strategy, series, index);\n\n//The service will tell us if the strategy sends a SELL signal over the given index on the BarSeries\nboolean shouldExit = PositionService.shouldExit(strategy, series, index);\n\n//The service will tell us if the strategy sends a BUY signal over the last Bar in the BarSeries\nboolean shouldEnter = PositionService.shouldEnter(strategy, series);\n\n//The service will tell us if the strategy sends a SELL signal over the last Bar in the BarSeries\nboolean shouldExit = PositionService.shouldExit(strategy, series);\n")),(0,i.kt)("h2",{id:"live-trading"},"Live trading"),(0,i.kt)("p",null,"First of all we need a Strategy callback."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"StrategyCallback callback = new StrategyCallback();\n\n//Stream is open\ncallback.onOpen(response -> {\n    //...\n});\n\n//Stream is closed\ncallback.onClosed(WebsocketCloseObject -> {\n    //...\n});\n\n//Stream is closing\ncallback.onClosing(WebsocketCloseObject -> {\n    //...\n});\n\n//Stream failure\ncallback.onFailure(apiException -> {\n    //...\n});\n//On BUY signal\ncallback.onEnter(barSeries -> {\n    //...\n});\n//On SELL signal\ncallback.onExit(barSeries -> {\n     //...\n});\n\n//On every received kline\ncallback.onMessage(symbolBar -> {\n    //...\n});\n")),(0,i.kt)("p",null,"Then a WatchService:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"//we will use the previous strategy\nWatchService service = new WatchService(strategy, callback);\n")),(0,i.kt)("p",null,"Now let's just run the service on the BTCBUSD pair on a 5min interval."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'service.watch("BTCBUSD", CandlestickInterval.FIVE_MINUTE);\n')),(0,i.kt)("p",null,"Closing the service:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"service.unwatch();\n")))}h.isMDXComponent=!0}}]);