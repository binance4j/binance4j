"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[5769],{1345:(e,t,n)=>{n(814),n(5162),n(5488),n(7294)},4344:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>k,frontMatter:()=>c,metadata:()=>l,toc:()=>d});var a=n(7462),o=(n(7294),n(3905)),i=n(2328),s=n(9497);n(1345);const c={title:"Connectors"},r=void 0,l={unversionedId:"connectors",id:"connectors",title:"Connectors",description:"Description",source:"@site/docs/15-connectors.mdx",sourceDirName:".",slug:"/connectors",permalink:"/binance4j/binance4j-documentation/docs/next/connectors",draft:!1,editUrl:"https://github.com/binance4j/docs/15-connectors.mdx",tags:[],version:"current",sidebarPosition:15,frontMatter:{title:"Connectors"},sidebar:"tutorialSidebar",previous:{title:"Core",permalink:"/binance4j/binance4j-documentation/docs/next/Core"},next:{title:"BLVT endpoints",permalink:"/binance4j/binance4j-documentation/docs/next/blvt"}},p={},d=[{value:"Description",id:"description",level:2},{value:"Installation",id:"installation",level:2},{value:"Connectors class",id:"connectors-class",level:2},{value:"Calling a client",id:"calling-a-client",level:2},{value:"Updating the API keys",id:"updating-the-api-keys",level:2}],u={toc:d};function k(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(s.ZP,{artifact:"connectors",mdxType:"RepoBadges"}),(0,o.kt)("h2",{id:"description"},"Description"),(0,o.kt)("p",null,"All Binance4j REST clients in one place."),(0,o.kt)("h2",{id:"installation"},"Installation"),(0,o.kt)(i.ZP,{repo:"connectors",mdxType:"ArtifactInstall"}),(0,o.kt)("h2",{id:"connectors-class"},"Connectors class"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Conectors")," class is the entry point of every client. It receives the API keys at instantiation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"Connectors connectors = new Connectors(key, secret);\n")),(0,o.kt)("h2",{id:"calling-a-client"},"Calling a client"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Conectors")," instance will lazy load the clients, meaning it won't instantiate every client at once but just when needed.\nThe client is then cached and the same instance is returned every time."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"// First call, the client is instantiated.\nconnectors.market().getServerTime().sync();\n// Second call, the same instance is returned.\nconnectors.market().getBookTicker().sync();\n")),(0,o.kt)("h2",{id:"updating-the-api-keys"},"Updating the API keys"),(0,o.kt)("p",null,"Every time you call a client, it will check if its keys are equal to the container keys and update them if not. This feature is really useful if you want to implement a proxy server for multiple users for example."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"//Updating keys in the container\nconnectors.updateKeys(key,secret);\n//keys have changed, they are updated in the client when it is called\nconnectors.spot();\n//keys haven't changed, nothing happens\nconnectors.spot();\n")))}k.isMDXComponent=!0},2328:(e,t,n)=>{n.d(t,{ZP:()=>r});var a=n(7462),o=(n(7294),n(3905)),i=n(112),s=n(8306);const c={toc:[]};function r(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(i.Z,{repo:n.repo,version:s.i,mdxType:"InstallationInstructions"}))}r.isMDXComponent=!0},9497:(e,t,n)=>{n.d(t,{ZP:()=>r});var a=n(7462),o=(n(7294),n(3905)),i=n(8267),s=n(8306);const c={toc:[]};function r(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(i.Z,{artifact:n.artifact,version:s.i,mdxType:"RepoBadges"}))}r.isMDXComponent=!0},8306:e=>{e.exports={i:"2.0.4"}}}]);