"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[3807],{9660:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>d,toc:()=>k});var i=t(7462),a=(t(7294),t(3905)),s=t(2106),o=t(6251),c=t(9960);const l={title:"Connectors",id:"connectors"},r=void 0,d={unversionedId:"connectors/connectors",id:"version-2.x/connectors/connectors",title:"Connectors",description:"Description",source:"@site/versioned_docs/version-2.x/15-connectors/index.mdx",sourceDirName:"15-connectors",slug:"/connectors/",permalink:"/binance4j/binance4j-documentation/docs/connectors/",draft:!1,editUrl:"https://github.com/binance4j/binance4j/versioned_docs/version-2.x/15-connectors/index.mdx",tags:[],version:"2.x",frontMatter:{title:"Connectors",id:"connectors"},sidebar:"tutorialSidebar",previous:{title:"Basics",permalink:"/binance4j/binance4j-documentation/docs/Basics/"},next:{title:"Trading strategies",permalink:"/binance4j/binance4j-documentation/docs/Strategy/"}},p={},k=[{value:"Description",id:"description",level:2},{value:"Installation",id:"installation",level:2},{value:"Instantiation",id:"instantiation",level:2},{value:"REST connectors",id:"rest-connectors",level:2},{value:"Calling a client",id:"calling-a-client",level:3},{value:"Updating the API keys",id:"updating-the-api-keys",level:3},{value:"Websocket connectors",id:"websocket-connectors",level:2},{value:"Clients watching specific symbols",id:"clients-watching-specific-symbols",level:3},{value:"Clients watching all symbols",id:"clients-watching-all-symbols",level:3},{value:"User data client",id:"user-data-client",level:3}],u={toc:k};function m(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)(o.ZP,{artifact:"connectors",mdxType:"RepoBadges"}),(0,a.kt)("h2",{id:"description"},"Description"),(0,a.kt)("p",null,"All REST and Websocket connectors in one place."),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)(s.ZP,{repo:"connectors",mdxType:"ArtifactInstall"}),(0,a.kt)("h2",{id:"instantiation"},"Instantiation"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Conectors")," class is the entry point of every client. It receives the API keys at instantiation."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"Connectors connectors = new Connectors(key, secret);\n")),(0,a.kt)("h2",{id:"rest-connectors"},"REST connectors"),(0,a.kt)("h3",{id:"calling-a-client"},"Calling a client"),(0,a.kt)("p",null,"Clients are singletons and are lazy loaded, meaning it will be instantiated on demand and will then always return the same instance of the client."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"// First call, the client is instantiated.\nconnectors.rest().market().getServerTime().sync();\n// Second call, the same instance is returned.\nconnectors.rest().market().getBookTicker().sync();\n")),(0,a.kt)("h3",{id:"updating-the-api-keys"},"Updating the API keys"),(0,a.kt)("p",null,"Every time you call a client, it will check if its keys are equal to the container keys and update them if not. This feature is useful if you manage multiple API keys."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"//Updating keys in the container\nconnectors.rest().updateKeys(key,secret);\n\n//keys have changed, they are updated in the client when it is called\nconnectors.rest().spot();\n\n//keys haven't changed, nothing happens\nconnectors.rest().spot();\n")),(0,a.kt)("h2",{id:"websocket-connectors"},"Websocket connectors"),(0,a.kt)("p",null,"Like REST clients, Websoket clients are Singletons."),(0,a.kt)("h3",{id:"clients-watching-specific-symbols"},"Clients watching specific symbols"),(0,a.kt)("p",null,"Every instance will be attached to it's symbol(s)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'// First call, the client is instantiated.\nconnectors.ws().bookTicker("BNBBTC,BTCBUSD,CAKEBUSD", callback).open();\n\n// To get the client, call it by its symbol. Every client is wrapped by an Optional object.\nOptional<WebsocketBookTickerClient> client = connectors.ws().bookTicker("BNBBTC,BTCBUSD,CAKEBUSD");\n\n//Check if client is not null and close it\nif(client.isPresent()){\n    client.get().close();\n}\n')),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Read more about Websocket client ",(0,a.kt)(c.Z,{to:"/docs/endpoints/websocket#event-callback",mdxType:"Link"},"Callbacks"))),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Defining a new client on the same symbols will overwrite the previous one.")),(0,a.kt)("h3",{id:"clients-watching-all-symbols"},"Clients watching all symbols"),(0,a.kt)("p",null,"Clients watching all symbols are called without argument:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"connectors.ws().allBookTickers(callback).open();\n\nconnectors.ws().allBookTickers().get();\n")),(0,a.kt)("h3",{id:"user-data-client"},"User data client"),(0,a.kt)("p",null,"User data client is linked by its ListenKey:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"WebsocketUserDataClient client = connectors.ws().user(callback);\nString key = client.getListenKey();\n\nclient.open();\n\nconnectors.ws().user(key).get();\n")))}m.isMDXComponent=!0},2106:(e,n,t)=>{t.d(n,{ZP:()=>l});var i=t(7462),a=(t(7294),t(3905)),s=t(5884),o=t(6867);const c={toc:[]};function l(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)(s.Z,{repo:t.repo,version:o.i,mdxType:"InstallationInstructions"}))}l.isMDXComponent=!0},6251:(e,n,t)=>{t.d(n,{ZP:()=>l});var i=t(7462),a=(t(7294),t(3905)),s=t(8267),o=t(6867);const c={toc:[]};function l(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)(s.Z,{artifact:t.artifact,version:o.i,mdxType:"RepoBadges"}))}l.isMDXComponent=!0},6867:e=>{e.exports={i:"2.3.0"}}}]);