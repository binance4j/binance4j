[{"title":"Core","type":0,"sectionRef":"#","url":"docs/Core","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"Core","url":"docs/Core#description","content":"Binance4j-core is the core module of the binance4j ecosystem. "},{"title":"Installation​","type":1,"pageTitle":"Core","url":"docs/Core#installation","content":""},{"title":"Apache Maven","type":1,"pageTitle":"Core","url":"docs/Core##","content":"pom.xml &lt;dependency&gt; &lt;groupId&gt;{{groupId}}&lt;/groupId&gt; &lt;artifactId&gt;{{artifactId}}&lt;/artifactId&gt; &lt;version&gt;{{version}}&lt;/version&gt; &lt;/dependency&gt;  "},{"title":"Gradle Groovy DSL","type":1,"pageTitle":"Core","url":"docs/Core##","content":"build.gradle implementation '{{groupId}}:{{artifactId}}:{{version}}'  "},{"title":"Dependencies​","type":1,"pageTitle":"Core","url":"docs/Core#dependencies","content":"Lombok : Prevent boilerplate code.OkHttp : HTTP &amp;&amp; Websocket clientsRetrofit : Map API endpoints with annotations.Jackson : Payload deserializationApache Common Codecs : Encode/decode urls "},{"title":"API Mapping​","type":1,"pageTitle":"Core","url":"docs/Core#api-mapping","content":"Every client mapping is represented by an interface with anotated methods defining the endpoint, the HTTP method, the request parameters, the response payload and when it must include the API credentials. This mapping is used by it's corresponding HTTP client. Here is a snippet of the SpotMapping code: public interface SpotMapping { /** The API key header */ public static final String API_H = AuthenticationInterceptor.ENDPOINT_SECURITY_TYPE_APIKEY_HEADER; /** The signed header */ public static final String SIGNED_H = AuthenticationInterceptor.ENDPOINT_SECURITY_TYPE_SIGNED_HEADER; @Headers({ API_H, SIGNED_H }) @POST(&quot;/api/v3/order&quot;) Call&lt;NewOrderResponse&gt; newOrder(@QueryMap Map&lt;String, Object&gt; map); }  Here we defined that sending an order requires to call POST on /api/v3/order endpoint with the order query params and include the public and signed keys in the headers. note The query parameters are converted from a Request Object to a Map by the client. "},{"title":"RestClient​","type":1,"pageTitle":"Core","url":"docs/Core#restclient","content":"Every HTTP client inherits from the RestClient class. Most of their constructor must receive a valid API KEY and SECRET KEY to be able to retrieve sensible data. Clients are linked to a Retrofit mappinq interface. Every method returns a RequestExecutor instance with a list of Retrofit calls for each available server. Here is a snippet of the SpotClient code: public class SpotClient extends RestClient&lt;SpotMapping&gt; { public SpotClient(String key, String secret, Boolean useTestnet) { super(SpotMapping.class, key, secret, useTestnet); } public SpotClient(String key, String secret) { this(key, secret, false); } public RequestExecutor&lt;NewOrderResponse&gt; newOrder(NewOrder order) { return new RequestExecutor&lt;&gt;(getServices().stream().map(a -&gt; a.newOrder(pojoToMap(order))).toList(), order); } }  HTTP clients can be configured through RestClient static parameters: apiPrefixes : The available servers (Default prefixes: api, api1, api2, api3)baseDomain : The API base domain (Default: binance.com)testnetDomain : The testnet API base domain (Default: testnet.binance.vision)timeInForce : how long an order will remain active before it is executed or expires (Default: TimeInForce.GTC)maxRequestsPerHost : max simultaneous requests per host (Default: 500)maxRequests : max simultaneous requests (Default: 500) "},{"title":"RequestExecutor​","type":1,"pageTitle":"Core","url":"docs/Core#requestexecutor","content":"It is not the client method that calls the API. Every method returns an instance of RequestExecutor that is able to make sync and async request to the API. Why not use directly the client method? Binance limits the number of request you can make in a defined interval of time but also limits requests by weight. Every request has its own weight. You can get the request weight with the Executor before calling the API and rate limit the requests to prevent being banned from the API.Binance is hosted on 4 servers represented by 4 prefixes. If one server is down, you can change it thanks to the Executor.It divides the clients code by 2. Here is an example of every possible type of request: SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); NewOrder request = new NewOrder(&quot;BNBBTC&quot;, OrderType.MARKET, OrderSide.BUY, new BigDecimal(&quot;100&quot;)); try{ NewOrderResponse response = client.newOrder(request).execute(); }catch(ApiException e){ //... }  "},{"title":"ApiCallback​","type":1,"pageTitle":"Core","url":"docs/Core#apicallback","content":"Every async call to the API made by the RequestExecutor is handled by a functional interface: ApiCallback. The interface has two methods: onResponse : it passes the deserialized data returned by the API.onFailure : it passes an ApiException if something went wrong. The onResponse handler is the default handler. It makes it possible for the async then method of the RequestExecutor to just use a lambda but it is not recommended as you would not be able to handle an ApiException. "},{"title":"WebsocketCallback​","type":1,"pageTitle":"Core","url":"docs/Core#websocketcallback","content":"Every Websocket client is using an inner WebsocketCallback to handle every connection event: onResponse : Triggered when the server sends dataonFailure : Triggered when the connection fails, deserialization fails, the server has not sent data for a long time.onClosing : Triggered when the connection is closingonClosed : Triggered when the connection is closedonOpen : Triggered when the connection is open "},{"title":"ApiException​","type":1,"pageTitle":"Core","url":"docs/Core#apiexception","content":"Any exception thrown by Binance4j is an ApiException. It contains a specific error message and an ErrorCode enum linked to an integer error code. These exceptions are thrown by sync methods and passed to the onFailure method of an ApiCallback or WebsocketCallback instance. "},{"title":"Testnet​","type":1,"pageTitle":"Core","url":"docs/Core#testnet","content":"Clients can connect to Binance Testnet servers From Binance: The testnet is a test environment for Binance Chain network, run by the Binance Chain development community, which is open to developers. The validators on the testnet are from development team. You can connect a node to the testnet by downloading the node binary to use this configuration. More "},{"title":"NFT","type":0,"sectionRef":"#","url":"docs/NFT","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"NFT","url":"docs/NFT#description","content":"Binance4j-nft is a Java connector for the NFT endpoints of the Binance REST API. "},{"title":"Installation​","type":1,"pageTitle":"NFT","url":"docs/NFT#installation","content":""},{"title":"Apache Maven","type":1,"pageTitle":"NFT","url":"docs/NFT##","content":"pom.xml &lt;dependency&gt; &lt;groupId&gt;{{groupId}}&lt;/groupId&gt; &lt;artifactId&gt;{{artifactId}}&lt;/artifactId&gt; &lt;version&gt;{{version}}&lt;/version&gt; &lt;/dependency&gt;  "},{"title":"Gradle Groovy DSL","type":1,"pageTitle":"NFT","url":"docs/NFT##","content":"build.gradle implementation '{{groupId}}:{{artifactId}}:{{version}}'  "},{"title":"Dependencies​","type":1,"pageTitle":"NFT","url":"docs/NFT#dependencies","content":"binance4j-core : The core of every binance4j artifactLombok : Prevent boilerplate code.OkHttp : HTTP &amp;&amp; Websocket clientsRetrofit : Map API endpoints with annotations.Jackson : Payload deserializationApache Common Codecs : Encode/decode urls "},{"title":"Get transaction history​","type":1,"pageTitle":"NFT","url":"docs/NFT#get-transaction-history","content":"                SyncAsync (lambda)Async (ApiCallback) NFTClient client = new NFTClient(key, secret); NFTTransactionHistoryRequest request = new NFTTransactionHistoryRequest(NFTOrderType.PURCHASE_ORDER); try{ NFTTransactionHistory response = client.getTransactions(request).execute(); }catch(ApiException e){ //... }  "},{"title":"Get deposit history​","type":1,"pageTitle":"NFT","url":"docs/NFT#get-deposit-history","content":"                SyncAsync (lambda)Async (ApiCallback) NFTClient client = new NFTClient(key, secret); try{ NFTDepositHistory response = client.getDeposits().execute(); }catch(ApiException e){ //... }  "},{"title":"Get withdraw history​","type":1,"pageTitle":"NFT","url":"docs/NFT#get-withdraw-history","content":"                SyncAsync (lambda)Async (ApiCallback) NFTClient client = new NFTClient(key, secret); try{ NFTWithdrawHistory response = client.getWithdraws().execute(); }catch(ApiException e){ //... }  "},{"title":"Get NFT assets​","type":1,"pageTitle":"NFT","url":"docs/NFT#get-nft-assets","content":"                SyncAsync (lambda)Async (ApiCallback) NFTClient client = new NFTClient(key, secret); try{ NFTAssetHistory response = client.getAssets().execute(); }catch(ApiException e){ //... }  "},{"title":"Market","type":0,"sectionRef":"#","url":"docs/Market","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"Market","url":"docs/Market#description","content":"Binance4j-market is a Java connector for the market endpoints of the Binance REST API. "},{"title":"Installation​","type":1,"pageTitle":"Market","url":"docs/Market#installation","content":""},{"title":"Apache Maven","type":1,"pageTitle":"Market","url":"docs/Market##","content":"pom.xml &lt;dependency&gt; &lt;groupId&gt;{{groupId}}&lt;/groupId&gt; &lt;artifactId&gt;{{artifactId}}&lt;/artifactId&gt; &lt;version&gt;{{version}}&lt;/version&gt; &lt;/dependency&gt;  "},{"title":"Gradle Groovy DSL","type":1,"pageTitle":"Market","url":"docs/Market##","content":"build.gradle implementation '{{groupId}}:{{artifactId}}:{{version}}'  "},{"title":"Dependencies​","type":1,"pageTitle":"Market","url":"docs/Market#dependencies","content":"binance4j-core : The core of every binance4j artifactLombok : Prevent boilerplate code.OkHttp : HTTP &amp;&amp; Websocket clientsRetrofit : Map API endpoints with annotations.Jackson : Payload deserializationApache Common Codecs : Encode/decode urls "},{"title":"Test connectivity​","type":1,"pageTitle":"Market","url":"docs/Market#test-connectivity","content":"          SyncAsync (lambda)Async (ApiCallback) MarketDataClient client = new MarketDataClient(key, secret); try{ client.ping().execute(); }catch(ApiException e){ //... }  "},{"title":"Get server time​","type":1,"pageTitle":"Market","url":"docs/Market#get-server-time","content":"             SyncAsync (lambda)Async (ApiCallback) MarketDataClient client = new MarketDataClient(key, secret); try{ ServerTimeResponse response = client.getServerTime().execute(); }catch(ApiException e){ //... }  "},{"title":"Get exchange info​","type":1,"pageTitle":"Market","url":"docs/Market#get-exchange-info","content":"                All symbolsOne symbolMultiple symbols SyncAsync (lambda)Async (ApiCallback) MarketDataClient client = new MarketDataClient(key, secret); try{ ExchangeInfo response = client.getExchangeInfo().execute(); }catch(ApiException e){ //... }  "},{"title":"Get a symbol's order book​","type":1,"pageTitle":"Market","url":"docs/Market#get-a-symbols-order-book","content":"                The term order book refers to an electronic list of buy and sell orders for a specific security or financial instrument organized by price level. An order book lists the number of shares being bid on or offered at each price point, or market depth. It also identifies the market participants behind the buy and sell orders, though some choose to remain anonymous. These lists help traders and also improve market transparency because they provide valuable trading information. Investopedia Default request (limit: 100)Request with limit SyncAsync (lambda)Async (ApiCallback) MarketDataClient client = new MarketDataClient(key, secret); OrderBookRequest request = new OrderBookRequest(&quot;BNBBTC&quot;); try{ OrderBook response = client.getOrderBook(request).execute(); }catch(ApiException e){ //... }  note The limit will determine the request weight warning The integer value must match one of the OrderBookLimit values or the request will fail "},{"title":"Get recent trades​","type":1,"pageTitle":"Market","url":"docs/Market#get-recent-trades","content":"                Default request (limit: 500)Request with max limit SyncAsync (lambda)Async (ApiCallback) MarketDataClient client = new MarketDataClient(key, secret); TradesRequest request = new TradesRequest(&quot;BNBBTC&quot;); try{ List&lt;TradeHistoryItem&gt; response = client.getTrades(request).execute(); }catch(ApiException e){ //... }  "},{"title":"Get historical trades​","type":1,"pageTitle":"Market","url":"docs/Market#get-historical-trades","content":"                Default request (limit: 500)Request with max limitFrom specific trade id SyncAsync (lambda)Async (ApiCallback) MarketDataClient client = new MarketDataClient(key, secret); HistoricalTradesRequest request = new HistoricalTradesRequest(&quot;BNBBTC&quot;); try{ List&lt;TradeHistoryItem&gt; response = client.getHistoricalTrades(request).execute(); }catch(ApiException e){ //... }  "},{"title":"Get compressed/aggregate trades List​","type":1,"pageTitle":"Market","url":"docs/Market#get-compressedaggregate-trades-list","content":"                Default request (limit: 500)Request with max limitFrom specific idWith start time and end time SyncAsync (lambda)Async (ApiCallback) MarketDataClient client = new MarketDataClient(key, secret); AggTradeRequest request = new AggTradeRequest(&quot;BNBBTC&quot;); try{ List&lt;AggTrade&gt; response = client.getAggTrades(request).execute(); }catch(ApiException e){ //... }  "},{"title":"Get Klines / candles​","type":1,"pageTitle":"Market","url":"docs/Market#get-klines--candles","content":"                With CandlestickIntervalWith String intervalWith a limitWith start time and end time SyncAsync (lambda)Async (ApiCallback) MarketDataClient client = new MarketDataClient(key, secret); KlinesRequest request = new KlinesRequest(&quot;BNBBTC&quot;, CandlestickInterval.FIVE_MINUTES); try{ List&lt;CandlestickBar&gt; response = client.getKlines(request).execute(); }catch(ApiException e){ //... }  note Default limit is 500, max is 1000. caution The String interval must correspond to one of the CandlestickInterval else the request will throw an ApiException "},{"title":"Get average price​","type":1,"pageTitle":"Market","url":"docs/Market#get-average-price","content":"                SyncAsync (lambda)Async (ApiCallback) MarketDataClient client = new MarketDataClient(key, secret); AveragePriceRequest request = new AveragePriceRequest(&quot;BNBBTC&quot;); try{ AveragePrice response = client.getAveragePrice(request).execute(); }catch(ApiException e){ //... }  "},{"title":"Get 24h ticker statistics​","type":1,"pageTitle":"Market","url":"docs/Market#get-24h-ticker-statistics","content":"                One symbolAll symbolsSpecific symbols SyncAsync (lambda)Async (ApiCallback) MarketDataClient client = new MarketDataClient(key, secret); TickerStatisticsRequest request = new TickerStatisticsRequest(&quot;BNBBTC&quot;); try{ TickerStatistics response = client.get24hTickerStatistics(request).execute(); }catch(ApiException e){ //... }  note Note the difference between TickerStatisticsRequest and TickersStatisticsRequest. The first is for one or all symbols, the other is for specific symbols. "},{"title":"Get price ticker​","type":1,"pageTitle":"Market","url":"docs/Market#get-price-ticker","content":"                One symbolAll symbolsSpecific symbols SyncAsync (lambda)Async (ApiCallback) MarketDataClient client = new MarketDataClient(key, secret); PriceTickerRequest request = new PriceTickerRequest(&quot;BNBBTC&quot;); try{ PriceTicker response = client.getTicker(request).execute(); }catch(ApiException e){ //... }  note Note the difference between PriceTickerRequest and PriceTickersRequest. The first is for one or all symbols, the other is for specific symbols. "},{"title":"Get order book ticker​","type":1,"pageTitle":"Market","url":"docs/Market#get-order-book-ticker","content":"                One symbolAll symbolsSpecific symbols SyncAsync (lambda)Async (ApiCallback) MarketDataClient client = new MarketDataClient(key, secret); BookTickerRequest request = new BookTickerRequest(&quot;BNBBTC&quot;); try{ BookTicker response = client.getBookTicker(request).execute(); }catch(ApiException e){ //... }  note Note the difference between BookTickerRequest and BookTickersRequest. The first is for one or all symbols, the other is for specific symbols. "},{"title":"Strategy","type":0,"sectionRef":"#","url":"docs/Strategy","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"Strategy","url":"docs/Strategy#description","content":"Binance4j-strategy adds technical analysis for the binance4j ecosystem. "},{"title":"Installation​","type":1,"pageTitle":"Strategy","url":"docs/Strategy#installation","content":""},{"title":"Apache Maven","type":1,"pageTitle":"Strategy","url":"docs/Strategy##","content":"pom.xml &lt;dependency&gt; &lt;groupId&gt;{{groupId}}&lt;/groupId&gt; &lt;artifactId&gt;{{artifactId}}&lt;/artifactId&gt; &lt;version&gt;{{version}}&lt;/version&gt; &lt;/dependency&gt;  "},{"title":"Gradle Groovy DSL","type":1,"pageTitle":"Strategy","url":"docs/Strategy##","content":"build.gradle implementation '{{groupId}}:{{artifactId}}:{{version}}'  "},{"title":"Dependencies​","type":1,"pageTitle":"Strategy","url":"docs/Strategy#dependencies","content":"binance4j-core : The core of every binance4j artifactbinance4j-vision : Retrieve Binance public databinance4j-websocket : Real-time market streamsLombok : Prevent boilerplate code.OkHttp : HTTP &amp;&amp; Websocket clientsRetrofit : Map API endpoints with annotations.Jackson : Payload deserializationApache Common Codecs : Encode/decode urls "},{"title":"Write a strategy​","type":1,"pageTitle":"Strategy","url":"docs/Strategy#write-a-strategy","content":" Binance4j uses ta4j for technical analysis and backtesting. To understand how indicators and rules work, read the library documentation //Every Strategy must extend BaseTradingStrategy public class TwoPeriodRSIStrategy extends BaseTradingStrategy { //This is where we define the rule that will send a BUY signal @Override public Rule getEntry(BarSeries series) { ClosePriceIndicator closePrice = new ClosePriceIndicator(series); SMAIndicator shortSma = new SMAIndicator(closePrice, 5); SMAIndicator longSma = new SMAIndicator(closePrice, 200); // We use a 2-period RSI indicator to identify buying // or selling opportunities within the bigger trend. RSIIndicator rsi = new RSIIndicator(closePrice, 2); // Entry rule // The long-term trend is up when a security is above its 200-period SMA. return new OverIndicatorRule(shortSma, longSma) // Trend .and(new CrossedDownIndicatorRule(rsi, 5)) // Signal 1 .and(new OverIndicatorRule(shortSma, closePrice)); // Signal 2 } //This is where we define the rule that will send a SELL signal @Override public Rule getExit(BarSeries series) { ClosePriceIndicator closePrice = new ClosePriceIndicator(series); SMAIndicator shortSma = new SMAIndicator(closePrice, 5); SMAIndicator longSma = new SMAIndicator(closePrice, 200); // We use a 2-period RSI indicator to identify buying // or selling opportunities within the bigger trend. RSIIndicator rsi = new RSIIndicator(closePrice, 2); // Exit rule // The long-term trend is down when a security is below its 200-period SMA. return new UnderIndicatorRule(shortSma, longSma) // Trend .and(new CrossedUpIndicatorRule(rsi, 95)) // Signal 1 .and(new UnderIndicatorRule(shortSma, closePrice)); // Signal 2 } }  "},{"title":"Backtest a strategy​","type":1,"pageTitle":"Strategy","url":"docs/Strategy#backtest-a-strategy","content":"    Use an external candlestickUse binance-vision // Let's get some public data with the vision SpotClient List&lt;CandlestickBar&gt; bars = new SpotClient() .getKlines(&quot;BNBBTC&quot;, CandlestickInterval.FIVE_MINUTES, &quot;2022&quot;, &quot;01&quot;) .getData(); //We instantiate the strategy TwoPeriodRSIStrategy strategy = new TwoPeriodRSIStrategy(); //We run the backtest on the series BackTestResult result = strategy.backTest(bars, CandlestickInterval.FIVE_MINUTES);  "},{"title":"Live trade​","type":1,"pageTitle":"Strategy","url":"docs/Strategy#live-trade","content":"    Live trading uses binance4j-websocket to get real-time klines data TwoPeriodRSIStrategy strategy = new TwoPeriodRSIStrategy(); //The stream callback StrategyCallback callback = new StrategyCallback(); //Stream is closed callback.onClosed(websocketCloseObject -&gt; { //... }); //Stream is closing callback.onClosing(WebsocketCloseObject -&gt; { //... }); //Stream is open callback.onOpen(response -&gt; { //... }); //connection failed/reading data failed/ping failed callback.onFailure(apiException -&gt; { //... }); //BUY signal (only called on final bar of interval) callback.onEnter(series -&gt; { //... }); //SELL signal (only called on final bar of interval) callback.onExit(series-&gt; { //... }); //every tick callback.onMessage(symbolBar -&gt; { //... }); // We set the inner BarSeries size. Default is 500. strategy.setMaximumBarCount(200); //We start live trading WebsocketClient wsClient = strategy.watch(&quot;BNBBTC&quot;, CandlestickInterval.ONE_MINUTE, callback); //We stop live trading strategy.unwatch();  "},{"title":"Watch multiple symbols​","type":1,"pageTitle":"Strategy","url":"docs/Strategy#watch-multiple-symbols","content":"A strategy can watch multiple symbols at the same time. Just use a string with symbols separated by a coma: WebsocketClient wsClient = strategy.watch(&quot;BNBBTC,BTCBUSD,SHIBBUSD&quot;, CandlestickInterval.ONE_MINUTE, callback);  or with a collection: WebsocketClient wsClient = strategy.watch(List.of(&quot;BNBBTC&quot;,&quot;BTCBUSD&quot;,&quot;SHIBBUSD&quot;), CandlestickInterval.ONE_MINUTE, callback);  The strategy will create a BarSeries instance for every symbol. To know the symbol of the series returned by onEnter and onExit, do as follow: callback.onEnter(series -&gt; { series.getName(); // returns the symbol }); callback.onExit(series-&gt; { series.getName(); // returns the symbol });  To know the symbol of the bar returned by onMessage, do as follow: //every tick callback.onMessage(symbolBar -&gt; { symbolBar.getSymbol(); // returns the symbol });  "},{"title":"Get strategy position over a candlestick​","type":1,"pageTitle":"Strategy","url":"docs/Strategy#get-strategy-position-over-a-candlestick","content":"The strategy can also give its trading position over the bars. // Let's get some public data with the vision SpotClient List&lt;CandlestickBar&gt; bars = new SpotClient() .getKlines(&quot;BNBBTC&quot;, CandlestickInterval.FIVE_MINUTES, &quot;2022&quot;, &quot;01&quot;) .getData(); // We instantiate the strategy TwoPeriodRSIStrategy strategy = new TwoPeriodRSIStrategy(); // Here we get the position of the strategy on the last bar of the series boolean shouldEnter = strategy.shouldEnter(bars, CandlestickInterval.FIVE_MINUTES); boolean shouldExit = strategy.shouldExit(bars, CandlestickInterval.FIVE_MINUTES); // Here we get the position of the strategy on the 6th bar of the series boolean shouldEnter = strategy.shouldEnter(bars, CandlestickInterval.FIVE_MINUTES, 5); boolean shouldExit = strategy.shouldExit(bars, CandlestickInterval.FIVE_MINUTES, 5);  The CandlestickBar list will be converted at every method call. To prevent useless computation, you can convert the list into a BarSeries before giving it to the methods. // Let's get some public data with the vision SpotClient List&lt;CandlestickBar&gt; bars = new SpotClient() .getKlines(&quot;BNBBTC&quot;, CandlestickInterval.FIVE_MINUTES, &quot;2022&quot;, &quot;01&quot;) .getData(); // We convert the bars into a BarSeries BarSeries series = BarSeriesService.convert(bars, CandlestickInterval.FIVE_MINUTES); //We instantiate the strategy TwoPeriodRSIStrategy strategy = new TwoPeriodRSIStrategy(); // Here we get the position of the strategy on the last bar of the series boolean shouldEnter = strategy.shouldEnter(series); boolean shouldExit = strategy.shouldExit(series); //Here we get the position of the strategy on the 6th bar of the series boolean shouldEnter = strategy.shouldEnter(series, 5); boolean shouldExit = strategy.shouldExit(series, 5);  "},{"title":"Spot","type":0,"sectionRef":"#","url":"docs/Spot","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"Spot","url":"docs/Spot#description","content":"Binance4j-spot is a Java connector for the SPOT endpoints of the Binance REST API. "},{"title":"Installation​","type":1,"pageTitle":"Spot","url":"docs/Spot#installation","content":""},{"title":"Apache Maven","type":1,"pageTitle":"Spot","url":"docs/Spot##","content":"pom.xml &lt;dependency&gt; &lt;groupId&gt;{{groupId}}&lt;/groupId&gt; &lt;artifactId&gt;{{artifactId}}&lt;/artifactId&gt; &lt;version&gt;{{version}}&lt;/version&gt; &lt;/dependency&gt;  "},{"title":"Gradle Groovy DSL","type":1,"pageTitle":"Spot","url":"docs/Spot##","content":"build.gradle implementation '{{groupId}}:{{artifactId}}:{{version}}'  "},{"title":"Dependencies​","type":1,"pageTitle":"Spot","url":"docs/Spot#dependencies","content":"binance4j-core : The core of every binance4j artifactLombok : Prevent boilerplate code.OkHttp : HTTP &amp;&amp; Websocket clientsRetrofit : Map API endpoints with annotations.Jackson : Payload deserializationApache Common Codecs : Encode/decode urls "},{"title":"Send an order​","type":1,"pageTitle":"Spot","url":"docs/Spot#send-an-order","content":"                Sends a trade order for execution. SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); NewOrder request = new NewOrder(&quot;BNBBTC&quot;, OrderType.MARKET, OrderSide.BUY, new BigDecimal(&quot;100&quot;)); try{ NewOrderResponse response = client.newOrder(request).execute(); }catch(ApiException e){ //... }  Here we executed a MARKET order to buy 100 BNB with BTC "},{"title":"NewOrder static methods​","type":1,"pageTitle":"Spot","url":"docs/Spot#neworder-static-methods","content":" The NewOrder class offers static methods to generate NewOrder instances. MARKET orderLIMIT orderQUOTE order Buy orderSell order NewOrder newOrder = NewOrder.buyMarket(&quot;BNBBTC&quot;, new BigDecimal(100));  "},{"title":"Test new order​","type":1,"pageTitle":"Spot","url":"docs/Spot#test-new-order","content":"             Tests the trade order without executing it. Works like the newOrder method. The request returns nothing but will throw an ApiException if it fails. SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); NewOrder request = new NewOrder(&quot;BNBBTC&quot;, OrderType.MARKET, OrderSide.BUY, new BigDecimal(&quot;100&quot;)); try{ client.newOrderTest(request).execute(); }catch(ApiException e){ //... }  "},{"title":"Cancel order​","type":1,"pageTitle":"Spot","url":"docs/Spot#cancel-order","content":"                Cancels an active order. SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); CancelOrderRequest request = new CancelOrderRequest(&quot;BNBBTC&quot;, 56935218L); try{ CancelOrderResponse response = client.cancelOrder(request).execute(); }catch(ApiException e){ //... }  Here we canceled the order on BNB/BTC with the 56935218L id "},{"title":"Cancel all open orders​","type":1,"pageTitle":"Spot","url":"docs/Spot#cancel-all-open-orders","content":"                Cancels all active orders on a symbol. This includes OCO orders. SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); CancelOpenOrdersRequest request = new CancelOpenOrdersRequest(&quot;BNBBTC&quot;); try{ List&lt;CancelOrderResponse&gt; response = client.cancelOpenOrders(request).execute(); }catch(ApiException e){ //... }  Here we canceled all open orders on BNB/BTC "},{"title":"Get order status​","type":1,"pageTitle":"Spot","url":"docs/Spot#get-order-status","content":"                Check an order's status. SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); OrderStatusRequest request = new OrderStatusRequest(&quot;BNBBTC&quot;, 65293729L); try{ OrderInfo response = client.getOrderStatus(request).execute(); }catch(ApiException e){ //... }  he we got the status of order on BNB/BTC with id 65293729 "},{"title":"Get open orders​","type":1,"pageTitle":"Spot","url":"docs/Spot#get-open-orders","content":"                Get all open orders on a symbol. Careful when accessing this with no symbol. All open ordersSpecific pair SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); try{ List&lt;OrderInfo&gt; response = client.getOpenOrders().execute(); }catch(ApiException e){ //... }  "},{"title":"Get all orders​","type":1,"pageTitle":"Spot","url":"docs/Spot#get-all-orders","content":"                Get all orders on a symbol. Get last 500 (default)Get last 1000 orders (max) SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); AllOrdersRequest request = new AllOrdersRequest(&quot;BNBBTC&quot;); try{ List&lt;OrderInfo&gt; response = client.getAllOrders(request).execute(); }catch(ApiException e){ //... }  "},{"title":"Send an OCO order​","type":1,"pageTitle":"Spot","url":"docs/Spot#send-an-oco-order","content":"                An OCO order is made of two LIMIT orders. The first to execute cancels the other. SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); OCOOrder request = new OCOOrder(&quot;BTCBUSD&quot;, OrderSide.BUY, new BigDecimal(1), new BigDecimal(50000), new BigDecimal(51000)); try{ OCOResponse response = client.newOCO(request).execute(); }catch(ApiException e){ //... }  Here we send an order to buy 1 BTC for 50000 BUSD or 51000 BUSD. "},{"title":"Cancel an OCO/order list​","type":1,"pageTitle":"Spot","url":"docs/Spot#cancel-an-ocoorder-list","content":"                All OCOwith order list idWith client order id SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); CancelOCORequest request = new CancelOCORequest(&quot;BNBBTC&quot;); try{ List&lt;OCOResponse&gt; response = client.cancelOCO(request).execute(); }catch(ApiException e){ //... }  note Canceling an individual leg will cancel the entire OCO. If both orderListId and listClientOrderID are provided, orderId takes precedence. "},{"title":"Retrieve an OCO order​","type":1,"pageTitle":"Spot","url":"docs/Spot#retrieve-an-oco-order","content":"                With client order idWith order list id SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); OCOInfoRequest request = new OCOInfoRequest(&quot;C3wyj4WVEktd7u9aVBRXcN&quot;); try{ OCOInfo response = client.queryOCO(request).execute(); }catch(ApiException e){ //... }  "},{"title":"Retrieve all OCO orders​","type":1,"pageTitle":"Spot","url":"docs/Spot#retrieve-all-oco-orders","content":"                last 500 OCO orders (default)last 1000 (max)With order idWith order id and limit SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); try{ List&lt;OCOInfo&gt; response = client.getAllOCO().execute(); }catch(ApiException e){ //... }  "},{"title":"Retrieve open OCO orders​","type":1,"pageTitle":"Spot","url":"docs/Spot#retrieve-open-oco-orders","content":"                SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); try{ List&lt;OCOInfo&gt; response = client.getOpenOCO().execute(); }catch(ApiException e){ //... }  "},{"title":"Get SPOT account infos​","type":1,"pageTitle":"Spot","url":"docs/Spot#get-spot-account-infos","content":"                SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); try{ Account response = client.getAccount().execute(); }catch(ApiException e){ //... }  "},{"title":"Get your trades for a symbol​","type":1,"pageTitle":"Spot","url":"docs/Spot#get-your-trades-for-a-symbol","content":"                Get last 500 (default)Get last 1000 orders (max) SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); MyTradesRequest request = new MyTradesRequest(&quot;BNBBTC&quot;); try{ List&lt;Trade&gt; response = client.getMyTrades(request).execute(); }catch(ApiException e){ //... }  "},{"title":"Get order count​","type":1,"pageTitle":"Spot","url":"docs/Spot#get-order-count","content":"                Displays the user's current order count usage for all intervals. May be useful when rate limiting. SyncAsync (lambda)Async (ApiCallback) SpotClient client = new SpotClient(key, secret); try{ List&lt;OrderCount&gt; response = client.getOrderCount().execute(); }catch(ApiException e){ //... }  "},{"title":"Vision","type":0,"sectionRef":"#","url":"docs/Vision","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"Vision","url":"docs/Vision#description","content":"Binance4j-vision is a Java connector for the public data endpoints of the Binance REST API. "},{"title":"Installation​","type":1,"pageTitle":"Vision","url":"docs/Vision#installation","content":""},{"title":"Dependencies​","type":1,"pageTitle":"Vision","url":"docs/Vision#dependencies","content":"binance4j-core : The core of every binance4j artifactLombok : Prevent boilerplate code.OkHttp : HTTP &amp;&amp; Websocket clientsRetrofit : Map API endpoints with annotations.Jackson : Payload deserializationApache Common Codecs : Encode/decode urls "},{"title":"Apache Maven","type":1,"pageTitle":"Vision","url":"docs/Vision##","content":"pom.xml &lt;dependency&gt; &lt;groupId&gt;{{groupId}}&lt;/groupId&gt; &lt;artifactId&gt;{{artifactId}}&lt;/artifactId&gt; &lt;version&gt;{{version}}&lt;/version&gt; &lt;/dependency&gt;  "},{"title":"Gradle Groovy DSL","type":1,"pageTitle":"Vision","url":"docs/Vision##","content":"build.gradle implementation '{{groupId}}:{{artifactId}}:{{version}}'  "},{"title":"SPOT endpoints​","type":1,"pageTitle":"Vision","url":"docs/Vision#spot-endpoints","content":""},{"title":"Get klines​","type":1,"pageTitle":"Vision","url":"docs/Vision#get-klines","content":"       ZippedIn a CSV format / 2D ListDeserializedGet Checksum MonthlyDaily Synchronous requestAsynchronous request with lambdaAsynchronous request with ApiCallback SpotClient client = new SpotClient(); try{ ZipInputStream response = client.getKlines(&quot;BNBBTC&quot;, CandlestickInterval.FIVE_MINUTE, &quot;2022&quot;, &quot;01&quot;).getZip(); }catch(ApiException e){ //... }  "},{"title":"Get trades​","type":1,"pageTitle":"Vision","url":"docs/Vision#get-trades","content":"       ZippedIn a CSV format / 2D ListDeserializedGet Checksum MonthlyDaily Synchronous requestAsynchronous request with lambdaAsynchronous request with ApiCallback SpotClient client = new SpotClient(); try{ ZipInputStream response = client.getTrades(&quot;BNBBTC&quot;, &quot;2022&quot;, &quot;01&quot;).getZip(); }catch(ApiException e){ //... }  "},{"title":"Get aggregate trades​","type":1,"pageTitle":"Vision","url":"docs/Vision#get-aggregate-trades","content":"       ZippedIn a CSV format / 2D ListDeserializedGet Checksum MonthlyDaily Synchronous requestAsynchronous request with lambdaAsynchronous request with ApiCallback SpotClient client = new SpotClient(); try{ ZipInputStream response = client.getAggTrades(&quot;BNBBTC&quot;, &quot;2022&quot;, &quot;01&quot;).getZip(); }catch(ApiException e){ //... }  "},{"title":"Wallet","type":0,"sectionRef":"#","url":"docs/Wallet","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#description","content":"Binance4j-wallet is a Java connector for the wallet enpoints of the Binance REST API. "},{"title":"Installation​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#installation","content":""},{"title":"Apache Maven","type":1,"pageTitle":"Wallet","url":"docs/Wallet##","content":"pom.xml &lt;dependency&gt; &lt;groupId&gt;{{groupId}}&lt;/groupId&gt; &lt;artifactId&gt;{{artifactId}}&lt;/artifactId&gt; &lt;version&gt;{{version}}&lt;/version&gt; &lt;/dependency&gt;  "},{"title":"Gradle Groovy DSL","type":1,"pageTitle":"Wallet","url":"docs/Wallet##","content":"build.gradle implementation '{{groupId}}:{{artifactId}}:{{version}}'  "},{"title":"Dependencies​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#dependencies","content":"binance4j-core : The core of every binance4j artifactLombok : Prevent boilerplate code.OkHttp : HTTP &amp;&amp; Websocket clientsRetrofit : Map API endpoints with annotations.Jackson : Payload deserializationApache Common Codecs : Encode/decode urls "},{"title":"Get system status​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-system-status","content":"                SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ SystemStatus response = client.getSystemStatus().execute(); }catch(ApiException e){ //... }  "},{"title":"Get all coins info​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-all-coins-info","content":"                SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ List&lt;CoinInformation&gt; response = client.getAllCoinsInfo().execute(); }catch(ApiException e){ //... }  "},{"title":"Get Account snapshot​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-account-snapshot","content":"                   SPOTMARGINFUTURES SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ SpotAccountSnapshotResponse response = client.getSpotAccountSnapshot().execute(); }catch(ApiException e){ //... }  "},{"title":"Enable fast withdraw switch​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#enable-fast-withdraw-switch","content":"             Enables fast withdraw switch under your account. You need to enable trade option for the api key which requests this endpoint. When Fast Withdraw Switch is on, transferring funds to a Binance account will be done instantly. There is no on-chain transaction, no transaction ID and no withdrawal fee. SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ client.enableFastWithdrawSwitch().execute(); }catch(ApiException e){ //... }  "},{"title":"Disable fast withdraw switch​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#disable-fast-withdraw-switch","content":"             Disables fast withdraw switch under your account. You need to enable trade option for the api key which requests this endpoint. SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ client.disableFastWithdrawSwitch().execute(); }catch(ApiException e){ //... }  "},{"title":"Withdraw​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#withdraw","content":"                If network not send, return with default network of the coin. You can get network and isDefault in networkList of a coin in the response of getAllCoinsInfo SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); WithdrawRequest request = new WithdrawRequest(new BigDecimal(1), &quot;BTC&quot;, &quot;0x00000000000000&quot;); try{ WithdrawResult response = client.withdraw(request).execute(); }catch(ApiException e){ //... }  "},{"title":"Get deposit history​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-deposit-history","content":"                Fetches the deposit history of one or multiple coins. All coinsSpecific coinBy status (DepositStatus)By status (int)By coin and status SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ List&lt;DepositHistory&gt; response = client.getDepositHistory().execute(); }catch(ApiException e){ //... }  note Please notice the default startTime and endTime to make sure that time interval is within 0-90 days. If both startTime and endTime are sent, time between startTime and endTime must be less than 90 days. "},{"title":"Get withdraw history​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-withdraw-history","content":"                Fetches the withdraw history of one or multiple coins. All coinsSpecific coinBy status (WithdrawStatus)By status (int)By coin and status SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ List&lt;WithdrawHistory&gt; response = client.getWithdrawHistory().execute(); }catch(ApiException e){ //... }  note Network may not be in the response for old withdraw. Please notice the default startTime and endTime to make sure that time interval is within 0-90 days. If both startTime and endTime are sent, time between startTime and endTime must be less than 90 days. If withdrawOrderId is sent, time between startTime and endTime must be less than 7 days. If withdrawOrderId is sent, startTime and endTime are not sent, will return last 7 days records by default. "},{"title":"Get deposit address​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-deposit-address","content":"                SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); WithdrawRequesDepositAddressRequest request = new WithdrawRequesDepositAddressRequest(&quot;BNB&quot;); try{ DepositAddress response = client.getDepositAddress(request).execute(); }catch(ApiException e){ //... }  note You can get network and isDefault in networkList in the response of getAllCoinsInfo If network is not sent, return with default network of the coin. "},{"title":"Get account status​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-account-status","content":"                SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ AccountStatus response = client.getAccountstatus().execute(); }catch(ApiException e){ //... }  "},{"title":"Get API trading status​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-api-trading-status","content":"                SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ ApiTradingStatus response = client.getApiTradingStatus().execute(); }catch(ApiException e){ //... }  "},{"title":"Get dust log​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-dust-log","content":"                SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ DustLog response = client.getDustLog().execute(); }catch(ApiException e){ //... }  "},{"title":"Do a dust transfer​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#do-a-dust-transfer","content":"                SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); DustTransferRequest request = new DustTransferRequest(List.of(&quot;BTC&quot;,&quot;SHIB&quot;,&quot;DOGE&quot;)); try{ DustTransferResponse response = client.dustTransfert(request).execute(); }catch(ApiException e){ //... }  "},{"title":"Get asset dividend record​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-asset-dividend-record","content":"                Last 20 (default)Specific coin last 20Last 500 records SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ AssetDividendRecord response = client.getAssetDividendRecord().execute(); }catch(ApiException e){ //... }  "},{"title":"Get asset detail​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-asset-detail","content":"                Get the details of all assets supported by Binance All assetsOne asset SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ Map&lt;String, AssetDetail&gt; response = client.getAssetDetail().execute(); }catch(ApiException e){ //... }  "},{"title":"Get trade fee​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-trade-fee","content":"                All pairsOne pair SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ List&lt;TradeFee&gt; response = client.getTradeFee().execute(); }catch(ApiException e){ //... }  "},{"title":"Make a universal transfer​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#make-a-universal-transfer","content":"                SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); WalletTransferRequest request = new WalletTransferRequest(new BigDecimal(&quot;100&quot;), &quot;BNB&quot;, WalletTransferType.MAIN_MARGIN); try{ WalletTransferResponse response = client.transfer(request).execute(); }catch(ApiException e){ //... }  "},{"title":"Get transfer history​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-transfer-history","content":"                SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); WalletTransferHistoryRequest request = new WalletTransferHistoryRequest(WalletTransferType.MAIN_MARGIN); try{ WalletTransferHistory response = client.getTransferHistory(request).execute(); }catch(ApiException e){ //... }  "},{"title":"Get funding asset​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-funding-asset","content":"                Fetches the funding wallet asset balance Currently supports querying the following business assets：Binance Pay, Binance Card, Binance Gift Card, Stock Token All balancesSpecificSAdd BTC valuation SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ List&lt;FundingAsset&gt; response = client.getFundingAsset().execute(); }catch(ApiException e){ //... }  "},{"title":"Get API permissions​","type":1,"pageTitle":"Wallet","url":"docs/Wallet#get-api-permissions","content":"                SyncAsync (lambda)Async (ApiCallback) WalletClient client = new WalletClient(key, secret); try{ ApiPermissions response = client.getApiPermissions().execute(); }catch(ApiException e){ //... }  "},{"title":"Websocket","type":0,"sectionRef":"#","url":"docs/Websocket","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#description","content":"Binance4j-websocket is a set of Java connectors for the Binance Websocket API. "},{"title":"Installation​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#installation","content":""},{"title":"Apache Maven","type":1,"pageTitle":"Websocket","url":"docs/Websocket##","content":"pom.xml &lt;dependency&gt; &lt;groupId&gt;{{groupId}}&lt;/groupId&gt; &lt;artifactId&gt;{{artifactId}}&lt;/artifactId&gt; &lt;version&gt;{{version}}&lt;/version&gt; &lt;/dependency&gt;  "},{"title":"Gradle Groovy DSL","type":1,"pageTitle":"Websocket","url":"docs/Websocket##","content":"build.gradle implementation '{{groupId}}:{{artifactId}}:{{version}}'  "},{"title":"Dependencies​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#dependencies","content":"binance4j-core : The core of every binance4j artifactLombok : Prevent boilerplate code.OkHttp : HTTP &amp;&amp; Websocket clientsRetrofit : Map API endpoints with annotations.Jackson : Payload deserializationApache Common Codecs : Encode/decode urlsRxJava : asynchronous and event-based programs by using observable sequences. "},{"title":"How does it work?​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#how-does-it-work","content":" The goal of a websocket client is to receive real time data from the Binance API through a persistent, bi-directional stream. This can be market or user/balance data. Every client share the same methods as they inherit from the WebsocketClient class. "},{"title":"Event handlers​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#event-handlers","content":"//The connection with the server is opened. client.onOpen(response -&gt; { // ... }); //The connection with the server is closing. client.onClosing(cb -&gt; { // ... }); //The connection with the server is closed. client.onClosed(cb -&gt; { // ... }); //Connection failed, deserialization failed, the server has not sent data for a long time (timeout) client.onFailure(cb -&gt; { // ... }); //The server pushed data client.onMessage(cb -&gt; { // ... });  "},{"title":"Open/Close the stream​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#openclose-the-stream","content":"//When the connection will open, the `onOpen` handler will be called. client.open(); //Before closing, the `onClosing` handler will be called, then `onClosed` once the connection is closed. client.close();  "},{"title":"Stream lifespan​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#stream-lifespan","content":"From Binance documentation: A single connection to stream.binance.com is only valid for 24 hours; expect to be disconnected at the 24 hour mark. The websocket server will send a ping frame every 3 minutes. If the websocket server does not receive a pong frame back from the connection within a 10 minute period, the connection will be disconnected. Unsolicited pong frames are allowed. Ping the server​ Websocket clients automatically ping the server every 3 minutes. You don't need to do anything! But if you want to change that interval, just call: client.setPingInterval(java.time.Duration)  caution The stream must be closed or this won't work. If you need to change this interval, close and reopen the stream. Ping the server back​ Again, websocket clients automatically pings back. You don't need to do anything! Reconnect after a disconnection​ Every websocket client is by default configured to automatically reconnect if the stream is closed by the server. If you don't like this behaviour, just call: client.setKeepAlive(false);  Next time the client is disconnected, it won't try to reconnect. Reconnect after a connection failure​ Every websocket client is by default configured to automatically reconnect after a connection failure. If you don't like this behaviour, just call: client.retryOnConnectionFailure(false);  caution The stream must be closed or this won't work. If you need to change this interval, close and reopen the stream. Reconnect after no response for some time​ It can happen that after some time, the server stops sending data to the client. Every websocket client is by default configured to automatically disconnect and reconnect after a not receiving data for some time (3 minutes by default). To change this interval call: client.setNoResponseTimeout(time.Duration);  caution The stream must be closed or this won't work. If you need to change this interval, close and reopen the stream. Since Binance recommends a 30 minutes interval, i wouldn't recommend to change this value. "},{"title":"Available Websocket clients​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#available-websocket-clients","content":""},{"title":"Individual Symbol Ticker Streams​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#individual-symbol-ticker-streams","content":"    Handles 24hr rolling window ticker statistics for a single symbol. One symbolMultiple symbols (String)Multiple symbols (List) WebsocketTickerClient client = new WebsocketTickerClient(&quot;BNBBTC&quot;);  caution These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. "},{"title":"Individual Symbol Mini Ticker Stream​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#individual-symbol-mini-ticker-stream","content":"    24hr rolling window mini-ticker statistics. caution These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. One symbolMultiple symbols (String)Multiple symbols (List) WebsocketMiniTickerClient client = new WebsocketMiniTickerClient(&quot;BNBBTC&quot;);  "},{"title":"All Market Tickers Stream​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#all-market-tickers-stream","content":"    24hr rolling window ticker statistics for all symbols that changed. WebsocketAllTickersClient client = new WebsocketAllTickersClient();  caution These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. "},{"title":"All Market Mini Tickers Stream​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#all-market-mini-tickers-stream","content":"    24hr rolling window mini-ticker statistics for all symbols that changed. WebsocketAllMiniTickersClient client = new WebsocketAllMiniTickersClient();  caution These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. "},{"title":"Individual Symbol Book Ticker Streams​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#individual-symbol-book-ticker-streams","content":"    Pushes any update to the best bid or ask's price or quantity in real-time for a specified symbol. One symbolMultiple symbols (String)Multiple symbols (List) WebsocketBookTickerClient client = new WebsocketBookTickerClient(&quot;BNBBTC&quot;);  "},{"title":"All Book Tickers Stream​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#all-book-tickers-stream","content":"    Pushes any update to the best bid or ask's price or quantity in real-time for all symbols. WebsocketAllBookTickersClient client = new WebsocketAllBookTickersClient();  "},{"title":"Kline/Candlestick Streams​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#klinecandlestick-streams","content":"    The Kline/Candlestick Stream push updates to the current klines/candlestick every second. One symbolMultiple symbols (String)Multiple symbols (List) WebsocketCandlestickClient client = new WebsocketCandlestickClient(&quot;BNBBTC&quot;, CandlestickInterval.FIVE_MINUTE);  "},{"title":"Diff. Depth Stream​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#diff-depth-stream","content":"    Order book price and quantity depth updates used to locally manage an order book. One symbolMultiple symbols (String)Multiple symbols (List) WebsocketDepthClient client = new WebsocketDepthClient(&quot;BNBBTC&quot;);  "},{"title":"Partial Book Depth Streams​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#partial-book-depth-streams","content":"    Top bids and asks, Valid are 5, 10, or 20. One symbolMultiple symbols (String)Multiple symbols (List) WebsocketMiniDepthClient client = new WebsocketMiniDepthClient(&quot;BNBBTC&quot;);  "},{"title":"Trade Streams​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#trade-streams","content":"    The Trade Streams push raw trade information; each trade has a unique buyer and seller. One symbolMultiple symbols (String)Multiple symbols (List) WebsocketTradeClient client = new WebsocketTradeClient(&quot;BNBBTC&quot;);  "},{"title":"Aggregate Trade Streams​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#aggregate-trade-streams","content":"    The Aggregate Trade Streams push trade information that is aggregated for a single taker order. One symbolMultiple symbols (String)Multiple symbols (List) WebsocketAggTradeClient client = new WebsocketAggTradeClient(&quot;BNBBTC&quot;);  "},{"title":"User Data Streams​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#user-data-streams","content":"    The User Data Streams push account, balance and order update infos. // Instantiate a UserDataClient UserDataClient userDataClient = new UserDataClient(key,secret); // instantiate the ws client WebsocketUserDataClient client = new WebsocketUserDataClient(userDataClient);  Account Update : outboundAccountPosition is sent any time an account balance has changed and contains the assets that were possibly changed by the event that generated the balance change. Balance Update: Balance Update occurs during the following: Deposits or withdrawals from the accountTransfer of funds between accounts (e.g. Spot to Margin) Order Update: Orders are updated with the executionReport event. Check the Public API Definitions and below for relevant enum definitions. Execution types: NEW - The order has been accepted into the engine.CANCELED - The order has been canceled by the user.REPLACED (currently unused)REJECTED - The order has been rejected and was not processed. (This is never pushed into the User Data Stream)TRADE - Part of the order or all of the order's quantity has filled.EXPIRED - The order was canceled according to the order type's rules (e.g. LIMIT FOK orders with no fill, LIMIT IOC or MARKET orders that partially fill) or by the exchange, (e.g. orders canceled during liquidation, orders canceled during maintenance) "},{"title":"Keep the User data Stream open​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#keep-the-user-data-stream-open","content":"From Binance documentation: The stream will close after 60 minutes unless a keepalive is sent. It's recommended to send a ping about every 30 minutes. The WebsocketUserDataClient constructor takes a UserDataCLient instance as parameter. In this way, it will automatically ask a listen key to the API and extends its lifespan by pinging the server every 30 minutes. The interval can be changed by calling: client.setKeepAliveInterval(java.time.Duration);  caution The stream must be closed or this won't work. If you need to change this interval, close and reopen the stream. Since Binance recommends a 30 minutes interval, i wouldn't recommend to change this value. "},{"title":"User data endpoints​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#user-data-endpoints","content":""},{"title":"Start user data stream​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#start-user-data-stream","content":"          Returns a listen key to open a user data websocket stream. SyncAsync (lambda)Async (ApiCallback) UserDataClient client = new UserDataClient(key, secret); try{ ListenKey response = client.startUserDataStream().execute(); }catch(ApiException e){ //... }  note The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes. "},{"title":"Keep alive user data stream​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#keep-alive-user-data-stream","content":"          Keepalive a user data stream to prevent a time out. SyncAsync (lambda)Async (ApiCallback) UserDataClient client = new UserDataClient(key, secret); String request = new String(/** listenKey */); try{ client.keepAliveUserDataStream(request).execute(); }catch(ApiException e){ //... }  note User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes. "},{"title":"Close out a user data stream​","type":1,"pageTitle":"Websocket","url":"docs/Websocket#close-out-a-user-data-stream","content":"          SyncAsync (lambda)Async (ApiCallback) UserDataClient client = new UserDataClient(key, secret); String request = new String(/** listenKey */); try{ client.loseUserDataStream(request).execute(); }catch(ApiException e){ //... }  "}]